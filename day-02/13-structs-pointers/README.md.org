* Structs y punteros
  :PROPERTIES:
  :CUSTOM_ID: structs-y-punteros
  :END:

Un =struct= es un tipo de dato definido por el usuario que representa
una colección de campos.

#+begin_src go
  type Employee struct {
      firstName string
      lastName string
      age int
  }
#+end_src

En el ejemplo anterior se define un =struct= con el nombre =Employee=
que contiene atributos de un empleado como =first name=, =last name= y
=age= con los respectivos tipos de datos de cada uno.

Los campos individuales de un =struct= se acceden con =.=.

#+begin_src go
  var emp := Employee {
      firstName: "Something"
  }

  fmt.Println(emp.firstName)

//Output: Something
#+end_src

** Campos struct
   :PROPERTIES:
   :CUSTOM_ID: campos-struct
   :END:

Golang permite que los campos de un =struct= puedan ser de tipo =struct=.

#+begin_src go
  type Address struct {
      city, state string
  }

  type Employee struct {
      firstName, lastName string
      age int
      address Address
  }
#+end_src

Para inicializar un campo =struct= simplemente nos referimos al mismo en
el bloque de inicialización

#+begin_src go
  var emp Employee

  emp := Employee{
      firstName: "Peter",
      lastName:  "Parker",
      age:       22,
      address: Address{
          city:  "New York",
          state: "New York",
      },
  }

  fmt.Println(emp)

//Output: {Peter  {New York New York}}
#+end_src

Los campos anidados se acceden con multiples niveles de notacion de
punto.

#+begin_src go
  fmt.Println(emp.address.city)

//Output: New York
#+end_src

** Composición
   :PROPERTIES:
   :CUSTOM_ID: composición
   :END:

Un =struct= puede tambien "heredar" todos los campos de otro usando
composición. Para esto existe una notación especial

#+begin_src go
  type Address struct {
      city, state string
  }

  type Employee struct {
      firstName, lastName string
      age int
      Address
  }
#+end_src

Nótese que aquí no se incluye un campo para =Address=, con lo que
indicamos que nuestro tipo =Employee= está compuesto por =Address=

Al crear una estructura compuesta tenemos que especificar todos los
campos

#+begin_src go
  emp := Employee{
      firstName: "Peter",
      lastName:  "Parker",
      age:       22,
      Address: Address{
          city:  "New York",
          state: "New York",
      },
  }
#+end_src

Los campos de la estructura interna son accesibles desde la externa.

#+begin_src go
  fmt.Println(emp.city)

//Output: New York
#+end_src

** Igualdad
   :PROPERTIES:
   :CUSTOM_ID: igualdad
   :END:

Un =struct= es un tipo por valor. Dos variables =struct= se consideran
iguales si todos los valores de sus campos son iguales. Esto quiere
decir que si un =struct= tiene campos que no se pueden comparar, como un
=map=, la operación (====) va a fallar.

** Métodos/Receptores
   :PROPERTIES:
   :CUSTOM_ID: methodsreceivers
   :END:

Los métodos (también llamados receptores) son funciones asociadas a un
tipo especifico. Son similares al concepto de métodos de clase en el
mundo OOP. La sintaxis es la siguiente:

#+begin_src go
  func (t Type) MethodName(parameter list) {
      // codigo del metodo
  }
#+end_src

Usualmente se define el código del método en el mismo archivo que el
tipo que lo contiene.

En el siguiente ejemplo se agrega el método =Print= al tipo =Employee=,
definido en los ejemplo anteriores, para imprimir el contenido del
registro mas claramente:

#+begin_src go
  // Receptor por valor
  func (e Employee) Print() {
      fmt.Println("Employee Record:")
      fmt.Println("Name:", e.firstName, e.lastName)
      fmt.Println("Address:", e.address)
  }

  var emp Employee

  emp.Print()

// Outpput  Employee Record:
//          Name: Allen Varghese
//          Address: {AA CO}
#+end_src

En el ejemplo anterior =e= es un parámetro implícto que se pasa al
método =Print= (como el =this= en Java y C#). En este caso el
parámetro se pasa /por valor/

** Punteros
   :PROPERTIES:
   :CUSTOM_ID: punteros
   :END:

Golang soporta punteros para actualizar valores pero no admite
aritmetica de punteros como en C. =*= se usa como prefijo para definir
un puntero para de un tipo dado. El operador =&= se usa para crear
punteros a tipos.

El valor por defecto de los punteros en Golang es =nil=, este valor
también se utiliza para indicar que un puntero es nulo.

Tener en cuenta que un puntero solo permite recibir punteros de su tipo
y no otros.

#+begin_src go
var emp *Employee // puntero nil

emp = &Employee{...} // puntero a Employee
#+end_src

Un puntero es una referencia a un tipo, por lo que podemos utilizarlo
para modificar el valor original. Los *receptores por puntero o por
referencia* son una aplicación directa de este concepto.

#+begin_src go
  // Receptor por puntero
  func (e *Employee) updateAge(newAge int) {
      e.age = newAge
  }
  emp := Employee{
      age: 33,
  }

  fmt.Println("Before:", emp.age)
  emp.updateAge(34)
  fmt.Println("After:", emp.age)

//Output: Before: 33
//        After: 34
#+end_src

En le ejemplo anterior el campo =age= se modifica en la variable
original. Para indicar este comportamiento notar el =*= antes del tipo
=Employee= en la definicion del metodo =updateAge=.

** Receptores: puntero o valor
   :PROPERTIES:
   :CUSTOM_ID: receptores-puntero-valor
   :END:

- Elección del tipo de receptor.
  1. Usar solo una variante de receptor para un mismo tipo.
  2. Ante la duda, usar receptores por puntero.
- Usar receptores por puntero.
  1. Cuando el método es inmutable.
  2. Para estructuras que contienen campos que no se deben copiar (ej. =sync.Mutex=).
  3. Para arreglos o estructuras de gran tamaño.
- Usar receptores por valor.
  1. Para tipos =map=, =func= o =chan=
  2. Para tipos básicos como =int= o =string=
  3. Cuando el tipo del receptor no contiene valores mutables
