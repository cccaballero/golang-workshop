* Interfaces
  :PROPERTIES:
  :CUSTOM_ID: interfaces
  :END:

** Interfaces en Golang
   :PROPERTIES:
   :CUSTOM_ID: interfaces-en-golang
   :END:

En Golang, una interfaz es un conjunto de firmas de métodos. Si un tipo
tiene una definición para esos metodos, se dice que implementa la
interfaz. A diferencia de otros lenguajes, /la asociacion de un tipo con
una interfaz es implicita/.

Es convención en Golang hacer interfaces que contengan pocos métodos.

Un tipo puede implementar mas de una interfaz.

#+begin_src go
  type Permanent struct {
      empID int
      basicPay int
      pension int
  }

  type Contract struct {
      empID int
      basicPay int
  }

  func (p Permanent) calculateSalary() int {
      return p.basicPay + p.pension
  }

  func (p Contract) calculateSalary() int {
      return p.basicPay
  }

  type SalaryCalculator interface {
      calculateSalary() int
  }

  // In main
  sc := [...]SalaryCalculator{Permanent{1, 5000, 50}, Contract{3, 7000}}
  totalPayout := 0
  for _, v := range sc {
      totalPayout += v.calculateSalary()
  }
  fmt.Println(totalPayout)
#+end_src

En el ejemplo anterior se definen dos tipos para cada categoría de
empleado, =Permanent= y =Contract=. El método =calculateSalary= se
define para los dos tipos. El cálculo es diferente para cada tipo.

El uso de la interfaz =SalaryCalculator= permite guardar en el arreglo
estructuras de tipo =Permanent= y =Contract= indistintamente. Cada
elemento del arreglo invocará al método =calculateSalary= del tipo
subyacente.

** Interfaces anidadas.
   :PROPERTIES:
   :CUSTOM_ID: interfaces-anidadas.
   :END:

Las interfaces al igual que las estructuras pueden anidarse.

#+begin_src go
  type Reader interface {
      Read(p []byte) (n int, err error)
  }

  type Seeker interface {
      Seek(offset int64, whence int) (int64, error)
  }

  type ReadSeeker interface {
      Reader
      Seeker
  }
#+end_src

Para que un tipo implemente la interfaz =ReadSeeker= tiene que
implementar =Read= y =Seeker= a la vez.

** Interfaces y composición.
   :PROPERTIES:
   :CUSTOM_ID: interfaces-y-composición.
   :END:

De la misma forma que una estructura "hereda" los métodos de otra en
la composición, implementa las interfaces de aquellas que la componen

#+begin_src go

  type Animal interface {
      Name() string
  }

  type Dog struct{}

  func (d *Dog) Name() string {
      return "Dog"
  }

  func Bark(d *Dog) {
      fmt.Println("Woof!")
  }

  type GuideDog struct {
      *Dog
  }
#+end_src

En el ejemplo anterior el tipo =GuidedDog= implementa la interfaz
=Animal=

** La interfaz vacía
   :PROPERTIES:
   :CUSTOM_ID: la-interfaz-vacía
   :END:

El tipo =interface{}= representa un valor comodín al estilo el tipo
=object= de C# o =void *= en C (tecnicamente todos los tipos
implementan una interfaz sin métodos)

#+begin_src go
  func describe(i interface{}) {
      fmt.Printf("(%v, %T)\n", i, i)
  }
#+end_src


** Punteros a interfaces
   :PROPERTIES:
   :CUSTOM_ID: punteros-a-interfaces
   :END:

Golang representa las interfaces como
